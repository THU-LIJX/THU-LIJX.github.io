---
title: Course Computer Graphics
date: 2022-10-02 13:34:07
updated: 2022-10-02 13:34:07
mathjax: true
tags:
---

## 计算机图形学课程笔记

### Lecture 3 图形的扫描转换与区域填充

**光栅图形学**

+ 基本图形的扫描转换 (scan conversion) ，如直线、圆弧、椭圆弧
+ 多边形的扫描转换与区域填充 (area filling)
+ 裁剪 (clipping)
+ 反走样 (antialiasing)
+ 投影 (projection)
+ 消隐 (visible-surface detection / hidden-surface elimintaion)

#### 直线的扫描转换

常用算法：

+ 数值微分法 (DDA)
+ 中点画线法
+ **Bresenham算法**

**数值微分法**

+ 基本思想
  + 知道了两个端点$P_0(x_0, y_0), P_1(x_1, y_1)$，则可以求出直线段的斜率$k$。当$0 < k < 1$时，根据公式$y = kx + b$来计算相应$y$坐标，取像素点$(x, \text{round}(y))$作为当前点的坐标；当$k \geq 1$时，根据$y$求取$x$的坐标
+ 增量算法
  + 在一个迭代算法中，每一步的$x, y$值使用上一步的值加上一个增量来获得
  + $y_{i+1} = y_i + k \Delta x$，当$\Delta x = 1$时，$y_{i+1} = y_i + k$
+ 优缺点：方法直观但效率低

**中点画线法**

+ 基本思想
  + 设当前像素点为$(x_p, y_p)$，下一个像素点为右侧$P_1$或右上角$P_2$两个点中的一个，设$M = (x_p + 1, y_p + 0.5)$为$P_1, P_2$的中点，$Q$为理想直线与$x = x_p + 1$的交点。将Q与M的y坐标值进行比较
    + 当$M$在$Q$点下方时，则右上角的$P_2$为下一个像素点
    + 当$M$在$Q$点上方时，则右侧的$P_1$为下一个像素点
  + 构造判别式，也即将$M$的坐标带入直线方程，$d = F(M) = a(x_p + 1) + b(y_p + 0.5) + c$
    + $a = y_0 - y_1, b = x_1 - x_0, c = x_0y_1 - x_1y_0$
    + $d > 0$，则$M$在Q点上方，取$P_1$
    + $d < 0$，则M在Q点下方，取$P_2$
    + $d = 0$，M、Q重合，此时取$P_1$或$P_2$都行
+ 增量算法
  + 若当前像素处于$d \geq 0$的情况，则取$P_1$，要判断下一个像素位置，应计算，$d_1 = F(x_p+2, y_p +0.5) = a(x_p+2) + b(y_p+0.5) + c = d + a$
  + 若当前像素处于$d < 0$的情况，则取$P_2$，要判断下一个像素位置，应计算，$d_2 = F(x_p+2, y_p + 1.5) = a(x_p + 2) + b(y_p + 1.5) + c = d + a + b$

**Bresenham算法**

+ 基本思想
  + 设直线方程为$y_{i+1} = y_i + k(x_{i+1} - x_i) = y_i + k$，因为直线的起始点在像素中心，所以误差项$d$的初始值为0
  + 当$d \geq 0.5$时，取$P_2$
  + 当$d < 0.5$时，取$P_1$
  + $x$的下标每增加1，$d$的值就相应递增直线的斜率$k$，当$d \geq 0.5$时，将$d$减去1

#### 圆弧的扫描转换

算法：

+ 中点画圆法
+ 正负法
+ 多边形逼近法

**中点画圆法**

+ 基本思想
  + 由于圆的对称性以及坐标轴的对称性，只需要画出八分之一圆弧即可得到整个圆弧
  + 考虑中心在原点，半径为$R$的圆在第一象限内$x\in [0, R/\sqrt{2}]$的八分之一圆弧
  + 构造判别式$F(x, y) = x^2 + y^2 - R^2$
  + 已知$P(x_p, y_p), P_1(x_p+1,y_p), P_2(x_p+1, y_p-1), M(x_p+1, y_p-0.5)$
  + $d = F(M) = F(x_p+1, y_p-0.5) = (x_p+1)^2 + (y_p-0.5)^2 - R^2$
    + 若$d < 0$，则取$P_1$为下一像素，而且再下一像素的判别式为$d' = F(x_p+2, y_p-0.5) = d+2x_p+3$
    + 若$d \geq 0$，则取$P_2$为下一像素，而且再下一像素的判别式为$d' = F(x_p+2, y_p-1.5) = d+2x_p-2y_p+5$
    + 第一个像素是$(0, R)$，判别式$d$的初始值是$d_0=F(1, R-0.5) = 1.25-R$

**正负法**

+ 基本思想
  + 由圆方程的隐函数$F(x, y) = x^2 + y^2 - R^2$，判断点与曲线的关系
  + 已知$P_i(x_i, y_i)$，求$P_{i+1}$的原则
    + 当$F(x_i, y_i) \leq 0$，则$P_{i+1} = (x_i+1, y_i), F(x_{i+1}, y_{i+1}) = F(x_i, y_i) +2x_i +1$
    + 当$F(x_i, y_i) \leq 0$，则$P_{i+1} = (x_i, y_i+1), F(x_{i+1}, y_{i+1}) = F(x_i, y_i) +2y_i +1$

#### 椭圆的扫描转换

**中点画法**

+ 基本思想
  + 由椭圆的对称性，可以只考虑第一象限椭圆弧生成
  + 将椭圆弧分为上下两部分，以椭圆弧上切线斜率为-1处作为分界点
  + 判别式$F(x, y) = b^2x^2 + a^2y^2 - a^2b^2$

#### 多边形的扫描转换

+ 多边形有两种重要的表示方式：**顶点表示**和**点阵表示**
+ 多边形的扫描转换：把多边形的顶点表示转换为点阵表示

算法：

+ 逐点判断法
  + 点在多边形内的判别方法
    + 射线法
    + 累计角度法
+ 扫描线算法
+ 边缘填充法
+ **边界标志法**

**逐点判断法**

+ 射线法
  + 从点*V*发出射线，与多边形相交，若交点个数为偶数，则*V*点在多边形外边，反之在多边形内
  + 若交点为多边形顶点，则需要判断该顶点对应的两条边是否在上下同侧
+ 累计角度法
  + 从$V$点向多边形$P$的各顶点发出射线，形成有向角，计算有向角之和
    + 和为0，则在外部
    + 和为$\pm 2\pi$，则在内部

**扫描线算法**

+ 基本思想
  + 按扫描线顺序，计算扫描线与多边形的相交区间，再用要求的颜色显示这些区间的像素，完成填充
  + 一条扫描线填充过程的步骤
    + 求交
    + 排序
    + 配对
    + 着色
+ 细节
  + 扫描线与多边形的顶点相交时，必须正确进行交点的取舍
  + 检查共享该顶点的两条边的另外两个端点的$y$值。交点个数为这两个点$y$值大于交点$y$值的个数
  + 问题：求交、排序导致算法效率低
  + 数据结构
    + **活性边表 (AET, Active Edge Table)**
      + 把与当前扫描线相交的边称为活性边，将它们按照与扫描线交点$x$坐标升序排列
      + 链表节点内容
        + $x:$ 当前扫描线与边的交点的$x$坐标
        + $\Delta x$：从当前扫描线到下一条扫描线间的$x$增量，如果扫描线时从低到高，**则$\Delta x$就是斜率的倒数**
        + $y_{max}$：该边所交的最高扫描线
    + 新边表 **(NET, New Egde Table)**
      + 存放在该扫描线第一次出现的边
        + 若某边的较低端点为$y_{min}$，则该边就放在扫描线$y_{min}$的新边表中
+ 算法大致过程：初始化新边表，对于每条扫描线，从新边表对应的位置中取出边，插入排序到活性边表中，然后将活性边表内的节点两两配对，得到着色区间，最后将活性边表的$x$值递增、同时去掉不需要的边

**边缘填充法**

+ 基本思想
  + 对于扫描线和各多边形的交点，将该扫描线上交点右方的所有像素颜色求补
  + 两种实现方式
    + 以扫描线为中心的边缘填充
    + 以边为中心的边缘填充
  + 引入栅栏提高效率

**边界标志法**

+ 基本思想
  + 对多边形的每条边进行直线扫描转换，也即对多边形边界所经过的像素打上标志
  + 采用和扫描线算法类似的方法进行着色
  + 使用一个布尔量inside来指示当前点是否在多边形内的状态
+ 需要注意两条边的交点计数次数

### Lecture 4 裁剪

裁剪：确定图形中哪些部分落在显示区之内，哪些落在显示区之外，以便只显示落在显示区内的那部分图形

+ 裁剪窗口、裁剪对象
+ 裁剪的时机（点阵图形 OR **参数图形**）

#### 直线段裁剪

算法：

+ 直接求交法
+ Cohen-Sutherland裁剪
+ 中点分割裁剪算法
+ Nicholl-Lee-Nicholl算法
+ 梁有栋—Barssky算法
+ Lyrus-Beck算法

**直接求交法**

+ 基本思想
  + 线段的两个端点都在窗口内，线段必定位于窗口内，即可见
  + 线段的两个端点同时位于窗口左侧、右侧、上侧或下侧，线段必定位于窗口外，不可见
  + 线段与窗口各边求交，得到可见部分
+ 算法过程
  + 过$P_1(x_1, y_1), P_2(x_2, y_2)$的直线$y = k(x - x_1) + y_1, k = (y_2 - y_1)/(x_2 - x_1)$
  + 直线与窗口各边所在直线交点
    + 左：$x=x_L, y=k(x_L - x_1) + y_1, k\neq\infty$
    + 右：$x=x_R, y=k(x_R - x_1) + y_1, k\neq\infty$
    + 上：$y=y_T, x = (y_T - y) / k + x_1, k\neq 0$
    + 下：$y=y_B, x = (y_B - y) / k + x_1, k\neq 0$

**Cohen-Sutherland裁剪**

**中点分割裁剪算法**

**Nicholl-Lee-Nicholl算法**

**Lyrus-Beck算法**

#### 多边形裁剪

算法

+ Sutherland-Hodgeman算法
+ **Weiler-Athenton算法**

**Weiler-Athenton算法**

+ 裁剪窗口，被裁剪多边形可以是任意多边形：凸、凹、带内环。裁剪窗口和被裁多边形地位对等
+ 被裁剪多边形为**主多边形**，裁剪窗口为**裁剪多边形**。同时约定顶点序列方向：外环为逆时针，内环为顺时针，这样便于之后判断入点出点
+ 基本思想
  + 裁剪结果区域由主多边形的部分边界和裁剪多边形的部分边界共同组成
  + 在交点处，边界发生交替
  + 交点成对出现
  + 入点：裁剪多边形外部$\rightarrow$裁剪多边形内部
  + 出点：裁剪多边形内部$\rightarrow$裁剪多边形外部
  + <img src="/Users/lijx/Library/Application Support/typora-user-images/image-20221006212118852.png" alt="image-20221006212118852" style="zoom:50%;" />
+ 算法流程
  + 建立主多边形和裁剪多边形的顶点表
  + 求交点、归类，并按顺序插入到顶点表中，在两个表的相应顶点间建立双向指针，便于之后查找
    + 判断出点、入点的方式：对两条相交的线段的向量求叉积（按照顶点遍历顺序得到向量），根据叉积结果的正负值来判断出点、入点，**坐标系为左手系和右手系的结果恰好相反。**
  + 裁剪过程
    + 如果还有未跟踪过的交点，创建一个新的多边形，同时任取一个作为起点，加入多边形的顶点表。否则算法结束
    + 如果该交点为入点，则在主多边形的顶点表中跟踪，取下一个节点。如果为出点，则在裁剪多边形的顶点表中跟踪。如果为多边形顶点，则保持当前跟踪的顶点表
    + 找到一个环后，得到一个多边形

### Lecture 5 图形变换与投影

+ 齐次坐标与二维图形的几何变换
+ 二维图形的显示流程
+ 三维图形的几何变换
+ 投影变换
+ 三维图形的显示流程



### Lecture 6 消隐

### Lecture 7 消隐2

### Lecture 8
